name: release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

env:
  GO_VERSION: "1.23.x"
  NODE_VERSION: "24.5.0"
  NPM_VERSION: "11.5.1"
  PROJECT_NAME: "BulkMailerGo"
  APP_DESKTOP_NAME: "Bulk Mailer Go"
  ICON_PNG: "build/appicon.png"
  WIN_EXE_X64: "build\\bin\\x64\\BulkMailerGo_x64.exe"
  WIN_EXE_ARM64: "build\\bin\\arm64\\BulkMailerGo_arm64.exe"

jobs:
  build:
    name: Build (${{ matrix.os }})
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Enforce npm version
        run: |
          npm i -g npm@${{ env.NPM_VERSION }}
          npm --version

      - name: Install Wails CLI
        run: go install github.com/wailsapp/wails/v2/cmd/wails@v2.10.2

      # ---------- Linux ----------
      - name: Install Linux GUI deps
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y libfuse2 build-essential pkg-config libgtk-3-dev libglib2.0-dev \
            libgirepository1.0-dev gir1.2-gtk-3.0 libayatana-appindicator3-dev \
            libx11-dev libxext-dev libxrandr-dev libxi-dev libxcursor-dev libxfixes-dev libxrender-dev libxinerama-dev \
            libwebkit2gtk-4.1-dev
          if [ -d "/usr/include/webkitgtk-4.1" ] && [ ! -e "/usr/include/webkitgtk-4.0" ]; then
            sudo ln -s /usr/include/webkitgtk-4.1 /usr/include/webkitgtk-4.0
          fi
          PKGDIR="/usr/lib/x86_64-linux-gnu/pkgconfig"; [ -d "$PKGDIR" ] || PKGDIR="/usr/lib/pkgconfig"
          if [ -f "$PKGDIR/webkit2gtk-4.1.pc" ] && [ ! -e "$PKGDIR/webkit2gtk-4.0.pc" ]; then
            sudo ln -s "$PKGDIR/webkit2gtk-4.1.pc" "$PKGDIR/webkit2gtk-4.0.pc"
          fi

      - name: Frontend install (clean)
        run: npm ci --prefix frontend

      - name: Frontend build
        run: npm run build --prefix frontend

      - name: Wails build (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig:${PKG_CONFIG_PATH:-}"
          wails build

      - name: Build AppImage (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          APPDIR="${{ env.PROJECT_NAME }}.AppDir"
          BIN_PATH="build/bin/${{ env.PROJECT_NAME }}"
          ICON_SRC="${{ env.ICON_PNG }}"
          DESKTOP_FILE="${{ env.PROJECT_NAME }}.desktop"
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool
          rm -rf "${APPDIR}"
          mkdir -p "${APPDIR}/usr/bin" "${APPDIR}/usr/share/icons/hicolor/256x256/apps" "${APPDIR}/usr/share/applications"
          cp "${BIN_PATH}" "${APPDIR}/usr/bin/${{ env.PROJECT_NAME }}"
          if [ -f "${ICON_SRC}" ]; then
            cp "${ICON_SRC}" "${APPDIR}/usr/share/icons/hicolor/256x256/apps/appicon.png"
            cp "${ICON_SRC}" "${APPDIR}/appicon.png"
          fi
          cat > "${APPDIR}/${DESKTOP_FILE}" <<EOF
          [Desktop Entry]
          Type=Application
          Name=${{ env.APP_DESKTOP_NAME }}
          Exec=${{ env.PROJECT_NAME }}
          Icon=appicon
          Categories=Network;Email;
          Comment=Professional Email Marketing Application
          Terminal=false
          EOF
          cat > "${APPDIR}/AppRun" <<'EOF'
          #!/bin/sh
          HERE="$(dirname "$(readlink -f "$0")")"
          export APPDIR="$HERE"
          exec "$HERE/usr/bin/BulkMailerGo" "$@"
          EOF
          chmod +x "${APPDIR}/AppRun"
          ./appimagetool "${APPDIR}" "${{ env.PROJECT_NAME }}_linux_x86_64.AppImage"

      - name: Prepare outputs (Linux)
        if: runner.os == 'Linux'
        run: |
          mkdir -p release_assets
          [ -f "${{ env.PROJECT_NAME }}_linux_x86_64.AppImage" ] && cp "${{ env.PROJECT_NAME }}_linux_x86_64.AppImage" release_assets/ || true

      # ---------- macOS ----------
      - name: Wails build (macOS)
        if: runner.os == 'macOS'
        run: wails build

      # Ensure icon exists and is referenced
      - name: Ensure app icon (.icns) in bundle (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME="${APP_DESKTOP_NAME}.app"
          ALT_NAME="${PROJECT_NAME}.app"
          if [ -d "build/bin/${APP_NAME}" ]; then
            APP_DIR="build/bin/${APP_NAME}"
          elif [ -d "build/bin/${ALT_NAME}" ]; then
            APP_DIR="build/bin/${ALT_NAME}"
          else
            echo "No .app found under build/bin"; ls -la build/bin || true; exit 1
          fi

          ICON_PNG="${ICON_PNG}"
          ICNS_PATH="${APP_DIR}/Contents/Resources/appicon.icns"
          mkdir -p "$(dirname "$ICNS_PATH")"

          if [ -f "$ICON_PNG" ]; then
            TMPSET="iconset"
            rm -rf "$TMPSET"; mkdir -p "$TMPSET"
            sips -z 16 16     "$ICON_PNG" --out "$TMPSET/icon_16x16.png" >/dev/null
            sips -z 32 32     "$ICON_PNG" --out "$TMPSET/icon_16x16@2x.png" >/dev/null
            sips -z 32 32     "$ICON_PNG" --out "$TMPSET/icon_32x32.png" >/dev/null
            sips -z 64 64     "$ICON_PNG" --out "$TMPSET/icon_32x32@2x.png" >/dev/null
            sips -z 128 128   "$ICON_PNG" --out "$TMPSET/icon_128x128.png" >/dev/null
            sips -z 256 256   "$ICON_PNG" --out "$TMPSET/icon_128x128@2x.png" >/dev/null
            sips -z 256 256   "$ICON_PNG" --out "$TMPSET/icon_256x256.png" >/dev/null
            sips -z 512 512   "$ICON_PNG" --out "$TMPSET/icon_256x256@2x.png" >/dev/null
            sips -z 512 512   "$ICON_PNG" --out "$TMPSET/icon_512x512.png" >/dev/null
            cp "$ICON_PNG" "$TMPSET/icon_512x512@2x.png" 2>/dev/null || true
            iconutil -c icns "$TMPSET" -o "$ICNS_PATH"
            rm -rf "$TMPSET"
          fi

          PLIST="${APP_DIR}/Contents/Info.plist"
          if /usr/libexec/PlistBuddy -c "Print :CFBundleIconFile" "$PLIST" >/dev/null 2>&1; then
            /usr/libexec/PlistBuddy -c "Set :CFBundleIconFile appicon" "$PLIST"
          else
            /usr/libexec/PlistBuddy -c "Add :CFBundleIconFile string appicon" "$PLIST"
          fi

      # Import Developer ID Application cert from secrets (p12)
      - name: Import signing certificate (macOS)
        if: runner.os == 'macOS'
        shell: bash
        env:
          P12_B64: ${{ secrets.DEVELOPER_ID_APP_CERT_BASE64 }}
          P12_PASS: ${{ secrets.CERT_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN="build.keychain"
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          security set-keychain-settings -lut 21600 "$KEYCHAIN"

          echo "$P12_B64" | base64 --decode > app.p12
          security import app.p12 -k "$KEYCHAIN" -P "$P12_PASS" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"
          security find-identity -v -p codesigning || true

      - name: Codesign .app (macOS)
        if: runner.os == 'macOS'
        shell: bash
        env:
          SIGN_IDENTITY_APP: ${{ secrets.SIGN_IDENTITY_APP }}
        run: |
          set -euo pipefail
          APP_NAME="${APP_DESKTOP_NAME}.app"
          ALT_NAME="${PROJECT_NAME}.app"
          if [ -d "build/bin/${APP_NAME}" ]; then
            APP_DIR="build/bin/${APP_NAME}"
          elif [ -d "build/bin/${ALT_NAME}" ]; then
            APP_DIR="build/bin/${ALT_NAME}"
          else
            echo "No .app found under build/bin"; exit 1
          fi

          codesign --force --options runtime --deep -s "$SIGN_IDENTITY_APP" "$APP_DIR"
          codesign --verify --deep --strict "$APP_DIR"

      - name: Create macOS DMG
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          APP_NAME="${APP_DESKTOP_NAME}.app"
          ALT_NAME="${PROJECT_NAME}.app"
          OUT_DMG="${PROJECT_NAME}_macOS.dmg"

          if [ -d "build/bin/${APP_NAME}" ]; then
            SRC_APP="build/bin/${APP_NAME}"
          elif [ -d "build/bin/${ALT_NAME}" ]; then
            SRC_APP="build/bin/${ALT_NAME}"
          else
            echo "No .app found under build/bin"
            ls -la build/bin || true
            exit 1
          fi

          DMG_DIR="dmgroot"
          rm -rf "${DMG_DIR}"
          mkdir -p "${DMG_DIR}"
          cp -R "${SRC_APP}" "${DMG_DIR}/"
          ln -s /Applications "${DMG_DIR}/Applications"
          hdiutil create -volname "${APP_DESKTOP_NAME}" -srcfolder "${DMG_DIR}" -ov -format UDZO "${OUT_DMG}"
          rm -rf "${DMG_DIR}"

      - name: Notarize + staple DMG (macOS)
        if: runner.os == 'macOS'
        shell: bash
        env:
          AC_API_KEY_ID: ${{ secrets.AC_API_KEY_ID }}
          AC_API_ISSUER_ID: ${{ secrets.AC_API_ISSUER_ID }}
          AC_API_KEY_BASE64: ${{ secrets.AC_API_KEY_BASE64 }}
        run: |
          set -euo pipefail
          OUT_DMG="${PROJECT_NAME}_macOS.dmg"
          echo "$AC_API_KEY_BASE64" | base64 --decode > authkey.p8
          xcrun notarytool submit "$OUT_DMG" --key authkey.p8 --key-id "$AC_API_KEY_ID" --issuer "$AC_API_ISSUER_ID" --wait
          xcrun stapler staple "$OUT_DMG"
          rm -f authkey.p8

      - name: Prepare outputs (macOS)
        if: runner.os == 'macOS'
        run: |
          mkdir -p release_assets
          [ -f "${{ env.PROJECT_NAME }}_macOS.dmg" ] && cp "${{ env.PROJECT_NAME }}_macOS.dmg" release_assets/ || true

      # ---------- Windows ----------
      - name: Build Windows x64 (Wails) and stage
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $env:GOOS  = "windows"
          $env:GOARCH = "amd64"
          wails build
          New-Item -ItemType Directory -Path (Split-Path "${{ env.WIN_EXE_X64 }}") -Force | Out-Null
          Copy-Item "build\bin\${{ env.PROJECT_NAME }}.exe" "${{ env.WIN_EXE_X64 }}" -Force
          Get-Item "${{ env.WIN_EXE_X64 }}" | Format-Table FullName,Length

      - name: Setup NSIS
        if: runner.os == 'Windows'
        run: choco install nsis -y

      - name: Build NSIS installer (x64)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $ws = (Get-Location).Path
          New-Item -ItemType Directory -Path "build\windows\dist" -Force | Out-Null
          & makensis "-DWORKSPACE=$ws" ".\build\windows\installer_x64.nsi"

      - name: Build Windows ARM64 (Wails) and stage
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $env:GOOS  = "windows"
          $env:GOARCH = "arm64"
          wails build
          New-Item -ItemType Directory -Path (Split-Path "${{ env.WIN_EXE_ARM64 }}") -Force | Out-Null
          Copy-Item "build\bin\${{ env.PROJECT_NAME }}.exe" "${{ env.WIN_EXE_ARM64 }}" -Force
          Get-Item "${{ env.WIN_EXE_ARM64 }}" | Format-Table FullName,Length

      - name: Build NSIS installer (ARM64)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $ws = (Get-Location).Path
          New-Item -ItemType Directory -Path "build\windows\dist" -Force | Out-Null
          & makensis "-DWORKSPACE=$ws" ".\build\windows\installer_arm64.nsi"

      - name: Prepare outputs (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          New-Item -ItemType Directory -Path release_assets -Force | Out-Null
          if (Test-Path "${{ env.WIN_EXE_X64 }}")   { Copy-Item "${{ env.WIN_EXE_X64 }}"   "release_assets\${{ env.PROJECT_NAME }}_windows_amd64.exe" -Force }
          if (Test-Path "${{ env.WIN_EXE_ARM64 }}") { Copy-Item "${{ env.WIN_EXE_ARM64 }}" "release_assets\${{ env.PROJECT_NAME }}_windows_arm64.exe" -Force }
          Get-ChildItem "build\windows\dist" -Filter "*.exe" -ErrorAction SilentlyContinue | ForEach-Object { Copy-Item $_.FullName release_assets\ -Force }

      # ---------- Upload artifacts (per OS, fixed names) ----------
      - name: Upload Linux outputs
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: Linux-artifacts
          path: release_assets/*

      - name: Upload macOS outputs
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: macOs-artifacts
          path: release_assets/*

      - name: Upload Windows outputs
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: Windows-artifacts
          path: release_assets/*

  publish:
    name: Publish GitHub Release
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download Linux artifacts
      # each artifact downloads as a zip by default
        uses: actions/download-artifact@v4
        with:
          name: Linux-artifacts
          path: artifacts/Linux

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: macOs-artifacts
          path: artifacts/macOS

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: Windows-artifacts
          path: artifacts/Windows

      - name: Unzip and collect binaries
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release_assets

          # Unzip all artifact zips
          find artifacts -type f -name "*.zip" -print0 | while IFS= read -r -d '' z; do
            dest="$(dirname "$z")/unzipped"
            mkdir -p "$dest"
            unzip -o "$z" -d "$dest" >/dev/null
          done

          # Collect .AppImage, .dmg, .exe from any depth
          find artifacts -type f \( -iname "*.appimage" -o -iname "*.dmg" -o -iname "*.exe" \) -print0 | \
            xargs -0 -I {} cp -f {} release_assets/

          echo "Final payload:"
          ls -la release_assets

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: release_assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
